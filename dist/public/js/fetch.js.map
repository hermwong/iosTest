{"version":3,"sources":["node_modules/browser-pack/_prelude.js","public/js/fetch/index.js","node_modules/whatwg-fetch/fetch.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"fetch.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nrequire('whatwg-fetch');\n\nvar fetchPolfill = self.fetch;\n\n// rough patch for https://github.com/github/fetch/issues/122\nself.fetch = function (url, opts) {\n  if (url.fetch) return url.fetch();\n  return fetchPolfill(url, opts);\n};\n\n// this seems to deal with the lack of clone\nResponse.prototype.clone = function () {\n  return this;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9oZXJtYW53L0RvY3VtZW50cy9oZXJtd29uZy9vZmZsaW5lLXdpa2lwZWRpYS9wdWJsaWMvanMvZmV0Y2gvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRXhCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7OztBQUc5QixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUMvQixNQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbEMsU0FBTyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQ2hDLENBQUM7OztBQUdGLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDcEMsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9oZXJtYW53L0RvY3VtZW50cy9oZXJtd29uZy9vZmZsaW5lLXdpa2lwZWRpYS9wdWJsaWMvanMvZmV0Y2gvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcblxudmFyIGZldGNoUG9sZmlsbCA9IHNlbGYuZmV0Y2g7XG5cbi8vIHJvdWdoIHBhdGNoIGZvciBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy8xMjJcbnNlbGYuZmV0Y2ggPSBmdW5jdGlvbih1cmwsIG9wdHMpIHtcbiAgaWYgKHVybC5mZXRjaCkgcmV0dXJuIHVybC5mZXRjaCgpO1xuICByZXR1cm4gZmV0Y2hQb2xmaWxsKHVybCwgb3B0cyk7XG59O1xuXG4vLyB0aGlzIHNlZW1zIHRvIGRlYWwgd2l0aCB0aGUgbGFjayBvZiBjbG9uZVxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufTsiXX0=","(function() {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    var self = this\n    if (headers instanceof Headers) {\n      headers.forEach(function(name, values) {\n        values.forEach(function(value) {\n          self.append(name, value)\n        })\n      })\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        self.append(name, headers[name])\n      })\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = name.toLowerCase()\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[name.toLowerCase()]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[name.toLowerCase()]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[name.toLowerCase()] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(name.toLowerCase())\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[name.toLowerCase()] = [value]\n  }\n\n  // Instead of iterable for now.\n  Headers.prototype.forEach = function(callback) {\n    var self = this\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      callback(name, self.map[name])\n    })\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    if (support.blob) {\n      this._initBody = function(body) {\n        this._bodyInit = body\n        if (typeof body === 'string') {\n          this._bodyText = body\n        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n          this._bodyBlob = body\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n          this._bodyFormData = body\n        } else if (!body) {\n          this._bodyText = ''\n        } else {\n          throw new Error('unsupported BodyInit type')\n        }\n      }\n\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this._initBody = function(body) {\n        this._bodyInit = body\n        if (typeof body === 'string') {\n          this._bodyText = body\n        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n          this._bodyFormData = body\n        } else if (!body) {\n          this._bodyText = ''\n        } else {\n          throw new Error('unsupported BodyInit type')\n        }\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(url, options) {\n    options = options || {}\n    this.url = url\n\n    this.credentials = options.credentials || 'omit'\n    this.headers = new Headers(options.headers)\n    this.method = normalizeMethod(options.method || 'GET')\n    this.mode = options.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && options.body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(options.body)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Request.prototype.fetch = function() {\n    var self = this\n\n    return new Promise(function(resolve, reject) {\n      var xhr = new XMLHttpRequest()\n      if (self.credentials === 'cors') {\n        xhr.withCredentials = true;\n      }\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(self.method, self.url, true)\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      self.headers.forEach(function(name, values) {\n        values.forEach(function(value) {\n          xhr.setRequestHeader(name, value)\n        })\n      })\n\n      xhr.send(typeof self._bodyInit === 'undefined' ? null : self._bodyInit)\n    })\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit)\n    this.type = 'default'\n    this.url = null\n    this.status = options.status\n    this.statusText = options.statusText\n    this.headers = options.headers\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function (url, options) {\n    return new Request(url, options).fetch()\n  }\n  self.fetch.polyfill = true\n})();\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9oZXJtYW53L0RvY3VtZW50cy9oZXJtd29uZy9vZmZsaW5lLXdpa2lwZWRpYS9wdWJsaWMvanMvZmV0Y2gvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRXhCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7OztBQUc5QixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUMvQixNQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbEMsU0FBTyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQ2hDLENBQUM7OztBQUdGLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDcEMsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDIiwiZmlsZSI6Ii9Vc2Vycy9oZXJtYW53L0RvY3VtZW50cy9oZXJtd29uZy9vZmZsaW5lLXdpa2lwZWRpYS9wdWJsaWMvanMvZmV0Y2gvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcblxudmFyIGZldGNoUG9sZmlsbCA9IHNlbGYuZmV0Y2g7XG5cbi8vIHJvdWdoIHBhdGNoIGZvciBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy8xMjJcbnNlbGYuZmV0Y2ggPSBmdW5jdGlvbih1cmwsIG9wdHMpIHtcbiAgaWYgKHVybC5mZXRjaCkgcmV0dXJuIHVybC5mZXRjaCgpO1xuICByZXR1cm4gZmV0Y2hQb2xmaWxsKHVybCwgb3B0cyk7XG59O1xuXG4vLyB0aGlzIHNlZW1zIHRvIGRlYWwgd2l0aCB0aGUgbGFjayBvZiBjbG9uZVxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzO1xufTsiXX0="}